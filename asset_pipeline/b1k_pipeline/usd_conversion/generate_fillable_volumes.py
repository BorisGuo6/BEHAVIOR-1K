import json
import math
import os
import random
import subprocess
from dask.distributed import Client, as_completed
import fs.copy
from fs.multifs import MultiFS
import fs.path
from fs.tempfs import TempFS
import tqdm

from b1k_pipeline.utils import ParallelZipFS, PipelineFS, TMP_DIR, launch_cluster

WORKER_COUNT = 4
BATCH_SIZE = 1

ids = {
    "aakcyj",
    "ackxiy",
    "adciys",
    "adiwil",
    "adxzhe",
    "aefcem",
    "aegxpb",
    "aeslmf",
    "aewpzn",
    "aewthq",
    "ahbhsd",
    "ahtzhp",
    "ajzltc",
    "akfjxx",
    "akusda",
    "amhlqh",
    "ankfvi",
    "apybok",
    "arryyl",
    "aspeds",
    "atgnsc",
    "avotsj",
    "aynjhg",
    "aysfhf",
    "azoiaq",
    "barzwx",
    "bbduix",
    "bbewjo",
    "bbpraa",
    "bdhvnt",
    "bedkqu",
    "belcml",
    "bexgtn",
    "bfaqfe",
    "bgxzec",
    "bnekjp",
    "bnobdx",
    "bnored",
    "bojwlu",
    "bovcqx",
    "bpwjxr",
    "bqpmsv",
    "bsdexp",
    "bsgybx",
    "bupgpj",
    "byzaxy",
    "bzisss",
    "bzsxgw",
    "causya",
    "cdmmwy",
    "cdteyb",
    "cdzyew",
    "ceaeqf",
    "cfdond",
    "chjetk",
    "cjmezk",
    "cjmtvq",
    "cjsbft",
    "ckkwmj",
    "ckxwea",
    "cmdagy",
    "coqeme",
    "cpozxi",
    "cprjvq",
    "cqdioi",
    "crlhmi",
    "csanbr",
    "csvdbe",
    "cvdbum",
    "cvyops",
    "cwkvib",
    "cydfkt",
    "cypjlv",
    "dafdgk",
    "dalyim",
    "dbprwc",
    "dcleem",
    "deudkt",
    "dfjcsi",
    "dhfqid",
    "dhgtvg",
    "dhkkfo",
    "dhnxww",
    "dhseui",
    "dhwlaw",
    "djgllo",
    "dkxddg",
    "dnqekb",
    "dnvpag",
    "dobgmu",
    "dpxnlc",
    "dtjmai",
    "duugbb",
    "dwspgo",
    "eahqyq",
    "eawgwj",
    "ecqxgd",
    "edfzlt",
    "effbnc",
    "efkgcw",
    "egpkea",
    "ehnmxj",
    "eipwho",
    "eixyyn",
    "ekjpdj",
    "elwfms",
    "eozsdg",
    "eqhgiy",
    "euqzpy",
    "euzudc",
    "evaida",
    "ewgotr",
    "exasdr",
    "exzsal",
    "eyedvd",
    "ezsdil",
    "fapsrj",
    "fbfmwt",
    "fedafr",
    "feuaak",
    "fgizgn",
    "fhdyrj",
    "fhfqys",
    "fhtvuq",
    "fiarri",
    "fjytro",
    "fkosow",
    "fkpaie",
    "foaehs",
    "fsfsas",
    "fsinsu",
    "fuzmdd",
    "fvkdos",
    "fwdfeg",
    "fwlabx",
    "fxnjfr",
    "fxrsyi",
    "fyrkzs",
    "fzhcdb",
    "gamkbo",
    "gcixra",
    "gcyvrx",
    "gejwoi",
    "gewlsk",
    "ggbdlq",
    "ggpnlr",
    "gilsji",
    "gjgwvi",
    "gklybu",
    "glwebh",
    "glzckq",
    "gnzegv",
    "gopbrh",
    "gqemcq",
    "gqtsam",
    "gqwnfv",
    "grrcna",
    "gsgutn",
    "gswpdr",
    "gsxbym",
    "guobeq",
    "gvnfgj",
    "gxajos",
    "gxiqbw",
    "gypzlg",
    "gzcqwx",
    "hacehh",
    "haewxp",
    "hamffy",
    "hazvbh",
    "hbjdlb",
    "hbsbwt",
    "hdbsog",
    "hdcpqg",
    "heuzgu",
    "hfclfn",
    "hhlmbi",
    "hitnkv",
    "hjjeeh",
    "hjxczh",
    "hkdsla",
    "hkwtnf",
    "hldhxl",
    "hliauj",
    "hlzfxw",
    "hmzafz",
    "hnlivs",
    "hpqjug",
    "hqdnjz",
    "htyvuz",
    "huwhjg",
    "hvlfig",
    "hvlkjx",
    "hxccge",
    "hxsyxo",
    "hynhgz",
    "hzspwg",
    "iaaiyi",
    "iadlti",
    "iawoof",
    "ibhhfj",
    "icpews",
    "icvmix",
    "ieoasd",
    "ifgcmr",
    "ifqdxn",
    "ifzxzj",
    "igyuko",
    "ihnfbi",
    "ihrjrb",
    "imsnkt",
    "incirm",
    "injdmj",
    "ipbgrw",
    "itoeew",
    "ivbrtz",
    "ivuveo",
    "iwfvwf",
    "iwwpsf",
    "iyrrna",
    "jasnzj",
    "jaypjo",
    "jblalf",
    "jdddsr",
    "jdijek",
    "jdwvyt",
    "jeqtzg",
    "jfvjep",
    "jgethp",
    "jgyqpd",
    "jgyzhv",
    "jhtxxh",
    "jjlfla",
    "jlalfc",
    "jlawet",
    "jnjtrl",
    "jpcflq",
    "jpduev",
    "jpvcjv",
    "jpwsrp",
    "jpzusm",
    "jvnqly",
    "jwxbpa",
    "jzmrdd",
    "kasebx",
    "kccqwj",
    "kdkrov",
    "kewbyf",
    "kiiamx",
    "kijnrj",
    "kitxam",
    "kjeudr",
    "kkjiko",
    "kkmkbd",
    "kohria",
    "krarex",
    "krfzqk",
    "krgqwl",
    "ksgizx",
    "kthvrl",
    "kttdbu",
    "ktuvuo",
    "kuiiai",
    "kvgaar",
    "kxovsj",
    "kxwgoo",
    "lbcxwi",
    "leazin",
    "lfjmos",
    "lfnbhc",
    "lgaxzt",
    "lgopij",
    "lgxhsc",
    "libote",
    "lixwwc",
    "lkbvad",
    "lkomhp",
    "llexze",
    "loduxu",
    "lpanoc",
    "lrjoro",
    "lsmlzi",
    "lspxjq",
    "luhkiz",
    "luhnej",
    "lulzdz",
    "lvqgvn",
    "lvuvbf",
    "lwsgzd",
    "lymciz",
    "lzdzkk",
    "mawxva",
    "mbrlge",
    "mcukuh",
    "mdmwcs",
    "mdojox",
    "mdtkkv",
    "meetii",
    "mefezc",
    "mgbeah",
    "mhhoga",
    "mhndon",
    "mkdcha",
    "mkstwr",
    "mmbavt",
    "mmegts",
    "molqhs",
    "mrgspe",
    "msaevo",
    "msfzpz",
    "mspdar",
    "mtetqm",
    "mvrhya",
    "mxsliu",
    "nawrfs",
    "nbctrk",
    "nbhcgu",
    "nbuspz",
    "ncbsee",
    "nedrsh",
    "nfoydb",
    "nftsal",
    "nfuxzd",
    "nhodax",
    "nhzrei",
    "nigfha",
    "nikfgd",
    "nkkhbn",
    "nmhxfz",
    "nodcpg",
    "npuuir",
    "nrjump",
    "ntedfx",
    "ntgftr",
    "nuoypc",
    "nuqzjs",
    "nuzkuf",
    "oadvet",
    "obuxbe",
    "ociqav",
    "ocjcgp",
    "odmjdd",
    "ofasfw",
    "omeuop",
    "omknho",
    "ompiss",
    "onbiqg",
    "ooyqcr",
    "oqyoos",
    "oshwps",
    "otyngn",
    "ouhqnw",
    "ovjhuf",
    "ovoceo",
    "owqbsb",
    "oxfzfe",
    "oxivmf",
    "oxknkz",
    "oyidja",
    "oyqdtz",
    "oywwzz",
    "ozrwwk",
    "pbvpua",
    "pdmzhv",
    "phimqa",
    "pihjqa",
    "pjaljg",
    "pjinwe",
    "pkfydm",
    "pkkgzc",
    "pobfpe",
    "ppdqbj",
    "ppzttc",
    "pqsamn",
    "ptciim",
    "pvxfot",
    "pyilfa",
    "pyttso",
    "qbxfmv",
    "qdnmwg",
    "qebiei",
    "qhnpmc",
    "qixpto",
    "qjhauf",
    "qlxhhh",
    "qmdgct",
    "qornxa",
    "qsdqik",
    "qtfzeq",
    "quzmfw",
    "qwoqqr",
    "qwthua",
    "qxnzpx",
    "qyuyjr",
    "qzodht",
    "rbnyxi",
    "rbqckd",
    "rclizj",
    "rfegnv",
    "rfigof",
    "rhohgs",
    "rixzrk",
    "rlwpcd",
    "rsvypp",
    "rteihy",
    "ruryqd",
    "rusmlm",
    "rwnakn",
    "rwotxo",
    "rxscji",
    "rypdvd",
    "saenda",
    "sbvksi",
    "sfbdjn",
    "sfkezf",
    "sfvswx",
    "siksnl",
    "skamgp",
    "skbcqq",
    "slscza",
    "smcyys",
    "snvhlz",
    "spopfj",
    "spppps",
    "sqqahm",
    "sstojv",
    "sthkfz",
    "stqkvx",
    "svkdji",
    "swytaw",
    "sxlklf",
    "szgdpc",
    "szjfpb",
    "szzjzd",
    "tfzfam",
    "tfzijn",
    "tgrsui",
    "thkphg",
    "tjrbxv",
    "tkgsho",
    "tmjxno",
    "tnjpsf",
    "toreid",
    "tqyiso",
    "trtrsl",
    "tsyims",
    "ttxunv",
    "tukaoq",
    "tvtive",
    "twknia",
    "txcjux",
    "tyczoo",
    "tzbnmh",
    "uaijua",
    "uakqei",
    "uartvl",
    "ueagnt",
    "uekqey",
    "uftzyo",
    "ugqdao",
    "ujodgo",
    "ukayce",
    "uknjdm",
    "uobdoq",
    "upfssc",
    "urqzec",
    "uumkbl",
    "uuypot",
    "uvzmss",
    "uwtdng",
    "uyixwc",
    "uzgibd",
    "uzkxtz",
    "vasiit",
    "vbiqcq",
    "vccsrl",
    "vckahe",
    "vcwsbm",
    "vghfkh",
    "vhglly",
    "vicaqs",
    "vitdwc",
    "vjbldp",
    "vjdkci",
    "vjqzwa",
    "vlplhs",
    "vlurir",
    "vmajcm",
    "vmbzmm",
    "vnvmkx",
    "vqtkwq",
    "vsxhsv",
    "vtjwof",
    "vxbtax",
    "vxmzmq",
    "vxqpnm",
    "vxtjjn",
    "vxxcvg",
    "vycozd",
    "waousd",
    "waqrdy",
    "wbnkfk",
    "wbwmcs",
    "wcqjew",
    "wdpcmk",
    "wengzf",
    "wfryvm",
    "wgcgia",
    "wigtue",
    "wivnic",
    "wklill",
    "wkxtxh",
    "wlilma",
    "wltgjn",
    "wmkwhg",
    "wopjex",
    "wqgndf",
    "wryghu",
    "wsasmm",
    "wtepsx",
    "wvhmww",
    "wvztiw",
    "wyojnz",
    "xbkwbi",
    "xcppkc",
    "xdahvv",
    "xdhysb",
    "xdxqxj",
    "xevdnl",
    "xfduug",
    "xfjmld",
    "xfqatj",
    "xifive",
    "xiwkwz",
    "xixblr",
    "xjdyon",
    "xjzyfc",
    "xkixrg",
    "xkqkbf",
    "xmxvml",
    "xnjqix",
    "xplzbo",
    "xpnlup",
    "xstykf",
    "xsuyua",
    "xtdcau",
    "xtqbuf",
    "xusefg",
    "xzcnjq",
    "ybhepe",
    "ycgxwb",
    "yfzibn",
    "ygrtaz",
    "yhurut",
    "yiamah",
    "yjmnej",
    "ykfkyq",
    "ykuftq",
    "ykysuc",
    "ylrxhe",
    "ynwamu",
    "yowyst",
    "yoxfyu",
    "ypdfrp",
    "yprkek",
    "yqtlhy",
    "ysdoep",
    "yufawg",
    "yvhmex",
    "yxaapv",
    "yzeuqo",
    "zaziny",
    "zbridw",
    "zcmnji",
    "zdeyzf",
    "zdvgol",
    "zfvhus",
    "zgzvcv",
    "zhsjcs",
    "ziomqg",
    "zlmnfg",
    "zndohl",
    "zotrbg",
    "zpddxu",
    "zsddtq",
    "zsrpiu",
    "ztripg",
    "ztyxyi",
    "zuctnl",
    "zwekzu",
    "zycgen",
}


def run_on_batch(dataset_path, batch, mode):
    if mode == "ray":
        script = "b1k_pipeline.usd_conversion.generate_fillable_volumes_process_ray"
    elif mode == "dip":
        script = "b1k_pipeline.usd_conversion.generate_fillable_volumes_process_dip"
    else:
        raise ValueError(f"Unknown mode: {mode}. Choose either ray or dip.")
    python_cmd = ["python", "-m", script, dataset_path] + batch
    cmd = ["micromamba", "run", "-n", "omnigibson", "/bin/bash", "-c", "source /isaac-sim/setup_conda_env.sh && " + " ".join(python_cmd)]
    obj = batch[0][:-1].split("/")[-1]
    with open(f"/scr/ig_pipeline/logs/{obj}.log", "w") as f, open(f"/scr/ig_pipeline/logs/{obj}.err", "w") as ferr:
        return subprocess.run(cmd, stdout=f, stderr=ferr, check=True, cwd="/scr/ig_pipeline")


def main():
    failed_objects = set()
    with PipelineFS() as pipeline_fs, \
         ParallelZipFS("objects_usd.zip") as objects_fs, \
         ParallelZipFS("metadata.zip") as metadata_fs, \
         ParallelZipFS("systems.zip") as systems_fs, \
         TempFS(temp_dir=str(TMP_DIR)) as dataset_fs:
        # with ParallelZipFS("fillable_volumes.zip", write=True) as out_fs:
        with pipeline_fs.makedirs("artifacts/parallels/fillable_volumes", recreate=True) as out_fs:
            # Copy everything over to the dataset FS
            print("Copying input to dataset fs...")
            fs.copy.copy_fs(metadata_fs, dataset_fs)
            fs.copy.copy_fs(systems_fs, dataset_fs)
            objdir_glob = list(objects_fs.glob("objects/*/*/"))
            for item in tqdm.tqdm(objdir_glob):
                if fs.path.parts(item.path)[-1] not in ids:
                    continue
                fs.copy.copy_fs(objects_fs.opendir(item.path), dataset_fs.makedirs(item.path))

            print("Launching cluster...")
            dask_client = launch_cluster(WORKER_COUNT)

            # Start the batched run
            object_glob = [x.path for x in dataset_fs.glob("objects/*/*/")]
            print("Queueing batches.")
            print("Total count: ", len(object_glob))

            # Make sure workers don't idle by reducing batch size when possible.
            batch_size = min(BATCH_SIZE, math.ceil(len(object_glob) / WORKER_COUNT))

            futures = {}
            for start in range(0, len(object_glob), batch_size):
                end = start + batch_size
                batch = object_glob[start:end]

                # First the logic for the ray method
                ray_outputs = [fs.path.join(x, "fillable_ray.obj") for x in batch]
                ray_remaining = list(zip(*[(x, y) for x, y in zip(batch, ray_outputs) if not out_fs.exists(y)]))
                if ray_remaining:
                    ray_batch, ray_outputs = ray_remaining
                    worker_future = dask_client.submit(
                        run_on_batch,
                        dataset_fs.getsyspath("/"),
                        list(ray_batch),
                        "ray",
                        pure=False)
                    futures[worker_future] = list(ray_outputs)

                # Then the dip method.
                dip_outputs = [fs.path.join(x, "fillable_dip.obj") for x in batch]
                dip_remaining = list(zip(*[(x, y) for x, y in zip(batch, dip_outputs) if not out_fs.exists(y)]))
                if dip_remaining:
                    dip_batch, dip_outputs = dip_remaining
                    worker_future = dask_client.submit(
                        run_on_batch,
                        dataset_fs.getsyspath("/"),
                        list(dip_batch),
                        "dip",
                        pure=False)
                    futures[worker_future] = list(dip_outputs)

            # Wait for all the workers to finish
            print("Queued all batches. Waiting for them to finish...")
            logs = []
            for future in tqdm.tqdm(as_completed(futures.keys()), total=len(futures)):
                # Check the batch results.
                batch = futures[future]
                if future.exception():
                    e = future.exception()
                    # logs.append({"stdout": e.stdout.decode("utf-8"), "stderr": e.stderr.decode("utf-8")})
                    print(e)
                else:
                    out = future.result()
                    # logs.append({"stdout": out.stdout.decode("utf-8"), "stderr": out.stderr.decode("utf-8")})

                # Copy the object to the output fs
                for item in batch:
                    dirpath = fs.path.dirname(item)
                    basename = fs.path.basename(item)
                    dataset_dir = dataset_fs.opendir(dirpath)
                    if dataset_dir.exists(basename):
                        fs.copy.copy_file(dataset_dir, basename, out_fs.makedirs(dirpath, recreate=True), basename)

            # Finish up.
            usd_glob = [x.path for x in dataset_fs.glob("objects/*/*/*.obj")]
            print(f"Done processing. Added {len(usd_glob)} objects. Archiving things now.")

        # Save the logs
        with pipeline_fs.pipeline_output().open("generate_fillable_volumes_flat.json", "w") as f:
            json.dump({
                "success": len(failed_objects) == 0,
                "failed_objects": sorted(failed_objects),
                "logs": logs,
            }, f)

if __name__ == "__main__":
    main()
